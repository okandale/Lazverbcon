-- schema.sql (run inside the laz_test database)
-- Purpose: create tables and relationships (no seed data)
-- IMPORTANT: run enums.sql BEFORE this file (because verb_form uses enum types)

CREATE TABLE IF NOT EXISTS dialect (
  dialect_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  english_name VARCHAR(128) NOT NULL,
  turkish_name VARCHAR(128) NOT NULL,
  laz_name     VARCHAR(128) NOT NULL,
  CONSTRAINT dialect_english_name_unique UNIQUE (english_name)
);

CREATE TABLE IF NOT EXISTS verb_category (
  verb_category_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code VARCHAR(16) NOT NULL UNIQUE,          -- e.g. 'tve', 'tvm'
  english_name VARCHAR(128) NOT NULL,
  turkish_name VARCHAR(128) NOT NULL,
  laz_name     VARCHAR(128)                 -- make NOT NULL later if you want
);

CREATE TABLE IF NOT EXISTS verb_family (
  verb_family_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  -- Groups all infinitives that derive from the same base (incl. preverb variants)
  -- Example: obaru (no preverb), mebaru, ebaru, ... should share the same verb_family_id
  family_code VARCHAR(128) UNIQUE
);

CREATE TABLE IF NOT EXISTS preverb (
  preverb_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  spelling      VARCHAR(128) NOT NULL UNIQUE,
  preverb_group VARCHAR(128),
  notes         TEXT
);



-- =========================
-- ROOT INFINITIVE = PREVERB connection through root
-- =========================
-- NOTE: This is NOT the same as verb_family.
-- - verb_family groups related lexical roots across dialects (e.g., uqoun ~ uyonun "to have").
-- - preverb_family groups preverb variants of the SAME underlying infinitive
--   (e.g., obaru, mebaru, ebaru share one preverb_family).
CREATE TABLE IF NOT EXISTS root_infinitive (
  root_infinitive_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  spelling VARCHAR(128) NOT NULL UNIQUE, -- e.g. "obaru"
  notes TEXT
);

CREATE TABLE IF NOT EXISTS verb (
  verb_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- verb_family_id groups related lexical roots across dialects (uqoun ~ uyonun), NOT preverb variants
  verb_family_id   INTEGER REFERENCES verb_family(verb_family_id),
  -- preverb_family_id groups preverb variants (obaru/mebaru/ebaru...), separate from verb_family
  preverb_family_id INTEGER REFERENCES preverb_family(preverb_family_id),
  dialect_id       INTEGER NOT NULL REFERENCES dialect(dialect_id),
  verb_category_id INTEGER NOT NULL REFERENCES verb_category(verb_category_id),

  infinitive  VARCHAR(128) NOT NULL,
  present_3sg VARCHAR(128) NOT NULL,

  meaning_english TEXT NOT NULL,
  meaning_turkish TEXT NOT NULL,

  -- verb-level requirements
  requires_marker BOOLEAN NOT NULL DEFAULT FALSE,

  -- verb-level optional prefix toggles (ko/do)
  has_optional_prefix_ko BOOLEAN NOT NULL DEFAULT FALSE,
  has_optional_prefix_do BOOLEAN NOT NULL DEFAULT FALSE,

  CONSTRAINT verb_unique_in_dialect UNIQUE (dialect_id, infinitive)
);

CREATE TABLE IF NOT EXISTS verb_preverb (
  verb_id    INTEGER NOT NULL REFERENCES verb(verb_id) ON DELETE CASCADE,
  preverb_id INTEGER NOT NULL REFERENCES preverb(preverb_id) ON DELETE RESTRICT,
  PRIMARY KEY (verb_id, preverb_id)
);

CREATE TABLE IF NOT EXISTS verb_form (
  verb_form_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  verb_id INTEGER NOT NULL REFERENCES verb(verb_id) ON DELETE CASCADE,

  -- Arguments
  subject person NOT NULL,
  object  person,

  -- Tense / derivation
  tense      tense NOT NULL,
  derivation derivation NOT NULL DEFAULT 'none',

  -- Clause properties
  mood mood NOT NULL DEFAULT 'indicative',

  -- Morphological operations
  is_applicative      BOOLEAN NOT NULL DEFAULT FALSE,
  is_causative        BOOLEAN NOT NULL DEFAULT FALSE,
  is_double_causative BOOLEAN NOT NULL DEFAULT FALSE,

  -- Optional prefix (ko/do); NULL means none
  optional_prefix optional_prefix,

  -- Final surface form
  spelling VARCHAR(128) NOT NULL
);

-- helpful indexes
CREATE INDEX IF NOT EXISTS idx_verb_dialect_id     ON verb(dialect_id);
CREATE INDEX IF NOT EXISTS idx_verb_category_id   ON verb(verb_category_id);
CREATE INDEX IF NOT EXISTS idx_verb_form_verb_id  ON verb_form(verb_id);
CREATE INDEX IF NOT EXISTS idx_verb_category_code ON verb_category(code);